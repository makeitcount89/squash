<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Processing and 3D Rendering</title>
  <!-- Include OpenCV.js -->
  <script async src="https://docs.opencv.org/master/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
  <!-- Include Babylon.js -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <style>
    .custom-file-input {
  padding: 15px; /* Adjust padding as needed */
  font-size: 50px; /* Adjust font size as needed */
  /* Add any additional styling you want */
    }
    
    .wide-slider {
  width: calc(100% + 40px); /* Adjust the width as needed */
  margin: 10px -20px; /* Compensate for the increased width */
    }
    
    #canvas2D,
    #canvas3D {
      border: 1px solid #000;
      margin-top: 20px;
    }

    body {
      font-size: 24px;
    }

    label {
      display: block;
      margin-top: 10px;
    }

    button {
      font-size: 24px;
      padding: 15px;
      margin: 10px;
    }

    input {
      font-size: 24px;
      margin: 10px;
    }
  </style>
</head>

<body>
  <input type="file" id="imageInput" accept="image/*" onchange="loadAndDetect()" class="custom-file-input">
  
  <label for="lineThreshold">Line Threshold:</label>
<input type="range" id="lineThreshold" class="wide-slider" min="1" max="1000" value="270" onchange="updateLineThreshold(this.value)">
<span id="lineThresholdValue">270</span>

<label for="lineThickness">Line Thickness:</label>
<input type="range" id="lineThickness" class="wide-slider" min="1" max="100" value="50" onchange="updateLineThickness(this.value)">
<span id="lineThicknessValue">50</span>
  
  <label for="wallColor">Wall Color:</label>
  <input type="color" id="wallColor" value="#000000">

  <label for="wallTexture">Wall Texture:</label>
  <input type="text" id="wallTexture" placeholder="Texture URL" value="https://www.babylonjs-playground.com/textures/brick.jpg">

  <label for="wallHeight">Wall Height:</label>
  <input type="number" id="wallHeight" value="250">

  <label for="wallThickness">Wall Thickness:</label>
  <input type="number" id="wallThickness" value="0.2">
<button onclick="drawLine()">Draw Line</button>
  <button onclick="deleteSelectedLines()">Eraser</button>
  <button onclick="undo()">Undo</button>
    
  <button onclick="convertTo3D()">Convert to 3D</button>
  <canvas id="canvas2D" width="600" height="600"></canvas>
  <canvas id="canvas3D" width="1200" height="1200"></canvas>

  <p id="coordinates"></p>

  <script>

    let img, context2D, babylonCanvas, detectedLines, scene, camera, startPoint; // Move 'scene' to a higher scope

    function onOpenCvReady() {
      // OpenCV is ready
    }

    function updateLineThreshold(value) {
      document.getElementById('lineThresholdValue').textContent = value;
      loadAndDetect(); // Trigger line detection on threshold change
    }

    function updateLineThickness(value) {
      document.getElementById('lineThicknessValue').textContent = value;
      // You can add real-time adjustment logic for line thickness here if needed
    }

    function loadAndDetect() {
  const input = document.getElementById('imageInput');
  img = new Image();
  img.onload = function () {
    context2D = document.getElementById('canvas2D').getContext('2d');
    context2D.clearRect(0, 0, context2D.canvas.width, context2D.canvas.height);
    context2D.drawImage(img, 0, 0, context2D.canvas.width, context2D.canvas.height);
    const threshold = parseInt(document.getElementById('lineThreshold').value);
    detectLines(threshold);

    // Draw the detected lines on the 2D canvas
    context2D.beginPath();
    context2D.strokeStyle = 'red'; // Change the color as needed
    detectedLines.forEach(line => {
      context2D.moveTo(line.x1, line.y1);
      context2D.lineTo(line.x2, line.y2);
    });
    context2D.stroke();
  };
  img.src = URL.createObjectURL(input.files[0]);
    }
    
    function detectLines(threshold) {
      if (!img) {
        alert('Please load an image first.');
        return;
      }

      const canvas2D = document.getElementById('canvas2D');
      const src = cv.imread(canvas2D);
      const dst = new cv.Mat();

      cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY);
      cv.Canny(src, dst, threshold, threshold * 2, 3, false); // Adjust the threshold here

      // Convert the detected lines to Babylon.js format
      detectedLines = [];
      const linesP = new cv.Mat();
      cv.HoughLinesP(dst, linesP, 1, Math.PI / 180, 100, 50, 10);

      for (let i = 0; i < linesP.rows; i++) {
        const line = linesP.data32S.subarray(i * 4, i * 4 + 4);
        detectedLines.push({
          x1: line[0],
          y1: line[1],
          x2: line[2],
          y2: line[3]
        });
      }

      src.delete();
      dst.delete();
      linesP.delete();
    }

    function convertTo3D() {
  resetCanvas();
  if (!detectedLines) {
    alert('Please detect lines first.');
    return;
  }

  // Determine the bounding box of the 3D object
  let minX = Number.MAX_VALUE;
  let minY = Number.MAX_VALUE;
  let maxX = Number.MIN_VALUE;
  let maxY = Number.MIN_VALUE;

  detectedLines.forEach(line => {
    minX = Math.min(minX, line.x1, line.x2);
    minY = Math.min(minY, -line.y1, -line.y2);
    maxX = Math.max(maxX, line.x1, line.x2);
    maxY = Math.max(maxY, -line.y1, -line.y2);
  });

  // Calculate the center and dimensions of the bounding box
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  const width = maxX - minX;
  const height = maxY - minY;

  // Create a ground plane
  const ground = BABYLON.MeshBuilder.CreateGround('ground', { width: width + 50, height: height}, babylonCanvas._babylonScene);
  const leftOffset = 350;  // Adjust this value to move the ground to the left
  const closerOffset = -880; // Adjust this value to move the ground closer

  ground.position = new BABYLON.Vector3(centerX - leftOffset, 0, -centerY + closerOffset);

  
  // Apply the original image as a texture to the ground
  const groundMaterial = new BABYLON.StandardMaterial('groundMaterial', babylonCanvas._babylonScene);
  groundMaterial.diffuseTexture = new BABYLON.Texture(img.src, babylonCanvas._babylonScene);
  ground.material = groundMaterial;

  detectedLines.forEach(line => {
    const lineThickness = parseFloat(document.getElementById('lineThickness').value);
    const wallColor = document.getElementById('wallColor').value;
    const wallTexture = document.getElementById('wallTexture').value;
    const wallHeight = parseFloat(document.getElementById('wallHeight').value);
    const wallThickness = parseFloat(document.getElementById('wallThickness').value);

    // Center and normalize the object
    const points = [
      new BABYLON.Vector3(line.x1 - centerX, 0, -line.y1 + centerY),
      new BABYLON.Vector3(line.x1 - centerX, wallHeight, -line.y1 + centerY),
      new BABYLON.Vector3(line.x2 - centerX, wallHeight, -line.y2 + centerY),
      new BABYLON.Vector3(line.x2 - centerX, 0, -line.y2 + centerY),
      new BABYLON.Vector3(line.x1 - centerX, 0, -line.y1 + centerY)
    ];

    const wallMesh = BABYLON.MeshBuilder.CreateDashedLines(null, { points, dashSize: lineThickness, updatable: true });
    wallMesh.color = new BABYLON.Color3.FromHexString(wallColor);

    if (wallTexture) {
      const wallMaterial = new BABYLON.StandardMaterial('wallMaterial', babylonCanvas._babylonScene);
      wallMaterial.diffuseTexture = new BABYLON.Texture(wallTexture, babylonCanvas._babylonScene);
      wallMesh.material = wallMaterial;
    }

    wallMesh.scaling.y = wallThickness;
  });
}


    // Load Babylon canvas on page load
  window.onload = function () {
  babylonCanvas = document.getElementById('canvas3D');
  const engine = new BABYLON.Engine(babylonCanvas, true);
  const scene = new BABYLON.Scene(engine);

  // Set up camera and light
  const camera = new BABYLON.UniversalCamera('camera', new BABYLON.Vector3(0, 0, -200), scene);
camera.setTarget(BABYLON.Vector3.Zero());
camera.attachControl(babylonCanvas, true);

// Animation parameters
const animationDuration = 700; // in milliseconds
const zoomedOutPosition = new BABYLON.Vector3(0, 140, -400);
    camera.rotation.x = Math.PI / 6; 

// Create a position animation
const animation = new BABYLON.Animation(
  'cameraZoom',
  'position',
  60,
  BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
  BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
);

// Set keyframes for the animation
const keys = [
  { frame: 0, value: camera.position.clone() },
  { frame: animationDuration, value: zoomedOutPosition }
];

// Add keys to the animation
animation.setKeys(keys);

// Attach the animation to the camera
camera.animations.push(animation);

// Run the animation
scene.beginAnimation(camera, 0, animationDuration, false);
    

  // Rotate the camera to face the object
  //camera.rotation.y = Math.PI; // Rotate by 180 degrees + 20 degrees
  //camera.rotation.x = Math.PI / 5; // Adjust the angle to tilt the camera down
    
  

  const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(1, 1, 0));

  // Set background color to a lighter gray
  scene.clearColor = new BABYLON.Color4(0.9, 0.9, 0.9, 1);

  // Run the Babylon.js engine
  engine.runRenderLoop(function () {
    scene.render();
  });
};


    function resetCanvas() {
  if (babylonCanvas) {
    // Hide the Babylon canvas
    babylonCanvas.style.display = 'none';

    // Create a new Babylon canvas element
    const newCanvas = document.createElement('canvas');
    newCanvas.width = babylonCanvas.width;
    newCanvas.height = babylonCanvas.height;
    babylonCanvas.parentNode.replaceChild(newCanvas, babylonCanvas);

    babylonCanvas = newCanvas;

    // Create a new Babylon engine and scene
    const engine = new BABYLON.Engine(babylonCanvas, true);
    const newScene = new BABYLON.Scene(engine);

    // Set up camera and light for the new scene (you may need to adjust these parameters)
    const camera = new BABYLON.UniversalCamera('camera', new BABYLON.Vector3(0, 0, -200), newScene);
    camera.setTarget(BABYLON.Vector3.Zero());
    camera.attachControl(babylonCanvas, true);
    const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(1, 1, 0));

    // Set background color to a lighter gray
    newScene.clearColor = new BABYLON.Color4(0.9, 0.9, 0.9, 1);

    // Animation parameters
    const animationDuration = 200; // in milliseconds
    const zoomedOutPosition = new BABYLON.Vector3(0, 115, -400);
    camera.rotation.x = Math.PI / 8; 

    // Create a position animation
    const animation = new BABYLON.Animation(
      'cameraZoom',
      'position',
      60,
      BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
      BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
    );

    // Set keyframes for the animation
    const keys = [
      { frame: 0, value: camera.position.clone() },
      { frame: animationDuration, value: zoomedOutPosition }
    ];

    // Add keys to the animation
    animation.setKeys(keys);

    // Attach the animation to the camera
    camera.animations.push(animation);

    // Run the animation
    newScene.beginAnimation(camera, 0, animationDuration, false);

    // Run the Babylon.js engine for the new scene
    engine.runRenderLoop(function () {
      newScene.render();
    });

    // Update the babylonCanvas and babylonScene variables
    babylonCanvas._babylonEngine = engine;
    babylonCanvas._babylonScene = newScene;

    // Show the new Babylon canvas
    babylonCanvas.style.display = 'block';
  }
    }
    
// Add timestamp property to the detectedLines array
//let detectedLines = [];

    function pointToLineDistance(point, line) {
  const { x: x0, y: y0 } = point;
  const { x: x1, y: y1, x: x2, y: y2 } = line;

  const A = y2 - y1;
  const B = x1 - x2;
  const C = (x2 - x1) * y1 + (y1 - y2) * x1;

  return Math.abs(A * x0 + B * y0 + C) / Math.sqrt(A * A + B * B);
    }
    


  // Add timestamp property to the detectedLines array
  //let detectedLines = [];

  // Add the drawLine function
  function drawLine() {
    const canvas2D = document.getElementById('canvas2D');
    const context2D = canvas2D.getContext('2d');

    // Capture mouse click coordinates
    canvas2D.addEventListener('click', function (event) {
      const mouseX = event.clientX - canvas2D.getBoundingClientRect().left;
      const mouseY = event.clientY - canvas2D.getBoundingClientRect().top;

      if (!startPoint) {
        // First click, set the start point
        startPoint = { x: mouseX, y: mouseY };
      } else {
        // Second click, draw the line and add coordinates with timestamp
        const endPoint = { x: mouseX, y: mouseY };

        // Draw the line on the canvas
        context2D.beginPath();
        context2D.strokeStyle = 'red'; // Change the color as needed
        context2D.moveTo(startPoint.x, startPoint.y);
        context2D.lineTo(endPoint.x, endPoint.y);
        context2D.stroke();

        // Add coordinates to the detectedLines array with timestamp
        const newLine = {
          x1: startPoint.x,
          y1: startPoint.y,
          x2: endPoint.x,
          y2: endPoint.y,
          timestamp: new Date()
        };
        detectedLines.push(newLine);

        // Reset start point for the next line
        startPoint = null;
      }
    });
  }

  // Add the deleteSelectedLines function
  function deleteSelectedLines() {
    if (!detectedLines) {
      alert('Please detect lines first.');
      return;
    }

    const canvas2D = document.getElementById('canvas2D');
    const context2D = canvas2D.getContext('2d');

    // Capture mouse click coordinates
    canvas2D.addEventListener('click', function (event) {
      const mouseX = event.clientX - canvas2D.getBoundingClientRect().left;
      const mouseY = event.clientY - canvas2D.getBoundingClientRect().top;

      // Check if clicked on a red line
      detectedLines.forEach((line, index) => {
        const distToLine = pointToLineDistance({ x: mouseX, y: mouseY }, line);
        if (distToLine < 5) { // Adjust the tolerance as needed
          // Add timestamp to the removed line
          line.timestamp = new Date();

          // Remove the selected line
          detectedLines.splice(index, 1);

          // Redraw the canvas without the deleted line
          context2D.clearRect(0, 0, canvas2D.width, canvas2D.height);
          context2D.drawImage(img, 0, 0, canvas2D.width, canvas2D.height);

          // Draw remaining lines
          context2D.beginPath();
          context2D.strokeStyle = 'red'; // Change the color as needed
          detectedLines.forEach(line => {
            context2D.moveTo(line.x1, line.y1);
            context2D.lineTo(line.x2, line.y2);
          });
          context2D.stroke();
        }
      });
    });
  }

  // Add the undo function
  function undo() {
    const canvas2D = document.getElementById('canvas2D');
    const context2D = canvas2D.getContext('2d');

    if (detectedLines.length > 0) {
      // Remove the last line from the array
      const removedLine = detectedLines.pop();

      // Clear the canvas
      context2D.clearRect(0, 0, canvas2D.width, canvas2D.height);
      context2D.drawImage(img, 0, 0, canvas2D.width, canvas2D.height);

      // Redraw remaining lines
      context2D.beginPath();
      context2D.strokeStyle = 'red'; // Change the color as needed
      detectedLines.forEach(line => {
        context2D.moveTo(line.x1, line.y1);
        context2D.lineTo(line.x2, line.y2);
      });
      context2D.stroke();

      // Check if the removed line has a timestamp
      if (removedLine.timestamp) {
        // Newly added line, log or handle accordingly
        console.log('Undid the last action (Added Line):', removedLine);
      } else {
        // Deleted line, log or handle accordingly
        console.log('Undid the last action (Deleted Line):', removedLine);
      }
    }
  }


    
  </script>
</body>

</html>
