<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Planner</title>
    <script defer src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        html, body { height: 100%; margin: 0; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            // Set up Babylon.js scene
            var canvas = document.createElement("canvas");
            document.body.appendChild(canvas);

            var engine = new BABYLON.Engine(canvas, true);
            var scene = new BABYLON.Scene(engine);
            var camera = new BABYLON.ArcRotateCamera("camera", 0, 0, 10, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);

            // Create 2D base (12m x 6m)
            var base = BABYLON.MeshBuilder.CreateBox("base", { width: 12, height: 6, depth: 0.1 }, scene);
            base.material = new BABYLON.StandardMaterial("baseMaterial", scene);
            base.material.wireframe = true;

            // Create 3D walls (20cm thick and 2m high)
            var walls = [
                BABYLON.MeshBuilder.CreateBox("topWall", { width: 12, height: 2, depth: 0.2 }, scene),
                BABYLON.MeshBuilder.CreateBox("bottomWall", { width: 12, height: 2, depth: 0.2 }, scene),
                BABYLON.MeshBuilder.CreateBox("leftWall", { width: 0.2, height: 6, depth: 2 }, scene),
                BABYLON.MeshBuilder.CreateBox("rightWall", { width: 0.2, height: 6, depth: 2 }, scene),
            ];

            // Position and adjust the walls
            walls[0].position.y = 3;
            walls[1].position.y = -3;
            walls[2].position.x = -6;
            walls[3].position.x = 6;

            walls.forEach(wall => {
                wall.material = new BABYLON.StandardMaterial("wallMaterial", scene);
                wall.material.wireframe = true;
            });

            // Set up camera position
            camera.setPosition(new BABYLON.Vector3(0, 0, 10));

            // Enable pinch zoom
            var pinchDistanceStart = 0;
            var pinchZoomSpeed = 0.1; // Adjust this value to control the zoom speed

            scene.onPointerObservable.add(function (pointerInfo) {
                switch (pointerInfo.type) {
                    case BABYLON.PointerEventTypes.POINTERDOWN:
                        if (pointerInfo.event.pointerType === "touch" && pointerInfo.pickInfo.pickedMesh === canvas) {
                            pinchDistanceStart = BABYLON.Tools.GetPointerCoordinates(pointerInfo.event)[0].distanceTo(BABYLON.Tools.GetPointerCoordinates(pointerInfo.event)[1]);
                        }
                        break;
                    case BABYLON.PointerEventTypes.POINTERUP:
                        pinchDistanceStart = 0;
                        break;
                    case BABYLON.PointerEventTypes.POINTERMOVE:
                        if (pinchDistanceStart > 0 && pointerInfo.event.pointerType === "touch" && pointerInfo.pickInfo.pickedMesh === canvas) {
                            var pinchDistance = BABYLON.Tools.GetPointerCoordinates(pointerInfo.event)[0].distanceTo(BABYLON.Tools.GetPointerCoordinates(pointerInfo.event)[1]);
                            var pinchDelta = pinchDistance - pinchDistanceStart;
                            camera.radius -= pinchDelta * pinchZoomSpeed;
                            pinchDistanceStart = pinchDistance;
                        }
                        break;
                }
            });

            // Render the scene
            engine.runRenderLoop(function () {
                scene.render();
            });

            // Handle window resize
            window.addEventListener('resize', function () {
                engine.resize();
            });
        });
    </script>
</body>
</html>
