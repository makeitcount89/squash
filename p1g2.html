<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Processing and 3D Rendering</title>
  <!-- Include OpenCV.js -->
  <script async src="https://docs.opencv.org/master/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
  <!-- Include Babylon.js -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <style>
    .custom-file-input {
      padding: 15px;
      font-size: 50px;
    }

    .wide-slider {
      width: calc(100% + 40px);
      margin: 10px -20px;
    }

    #canvas2D,
    #canvas3D {
      border: 1px solid #000;
      margin-top: 20px;
    }

    body {
      font-size: 24px;
    }

    label {
      display: block;
      margin-top: 10px;
    }

    button {
      font-size: 24px;
      padding: 15px;
      margin: 10px;
    }

    input {
      font-size: 24px;
      margin: 10px;
    }
  </style>
</head>

<body>
  <input type="file" id="imageInput" accept="image/*" onchange="loadAndDetect()" class="custom-file-input">

  <label for="lineThreshold">Line Threshold:</label>
  <input type="range" id="lineThreshold" class="wide-slider" min="1" max="1000" value="270" onchange="updateLineThreshold(this.value)">
  <span id="lineThresholdValue">270</span>

  <label for="lineThickness">Line Thickness:</label>
  <input type="range" id="lineThickness" class="wide-slider" min="1" max="100" value="50" onchange="updateLineThickness(this.value)">
  <span id="lineThicknessValue">50</span>

  <label for="wallColor">Wall Color:</label>
  <input type="color" id="wallColor" value="#000000">

  <label for="wallTexture">Wall Texture:</label>
  <input type="text" id="wallTexture" placeholder="Texture URL" value="https://www.babylonjs-playground.com/textures/brick.jpg">

  <label for="wallHeight">Wall Height:</label>
  <input type="number" id="wallHeight" value="250">

  <label for="wallThickness">Wall Thickness:</label>
  <input type="number" id="wallThickness" value="0.2">
  <button onclick="drawLine()">Draw Line</button>
  <button onclick="deleteSelectedLines()">Eraser</button>
  <button onclick="undo()">Undo</button>

  <button onclick="convertTo3D()">Convert to 3D</button>
  <canvas id="canvas2D" width="600" height="600"></canvas>
  <canvas id="canvas3D" width="1200" height="1200"></canvas>

  <p id="coordinates"></p>

  <script>
    let img, context2D, babylonCanvas, detectedLines, scene, camera, startPoint;

    function onOpenCvReady() {
      // OpenCV is ready
    }

    function updateLineThreshold(value) {
      document.getElementById('lineThresholdValue').textContent = value;
      loadAndDetect(); // Trigger line detection on threshold change
    }

    function updateLineThickness(value) {
      document.getElementById('lineThicknessValue').textContent = value;
      // You can add real-time adjustment logic for line thickness here if needed
    }

    function loadAndDetect() {
      const input = document.getElementById('imageInput');
      img = new Image();
      img.onload = function () {
        context2D = document.getElementById('canvas2D').getContext('2d');
        context2D.clearRect(0, 0, context2D.canvas.width, context2D.canvas.height);
        context2D.drawImage(img, 0, 0, context2D.canvas.width, context2D.canvas.height);
        const threshold = parseInt(document.getElementById('lineThreshold').value);
        detectLines(threshold);

        // Draw the detected lines on the 2D canvas
        context2D.beginPath();
        context2D.strokeStyle = 'red'; // Change the color as needed
        detectedLines.forEach(line => {
          context2D.moveTo(line.x1, line.y1);
          context2D.lineTo(line.x2, line.y2);
        });
        context2D.stroke();
      };
      img.src = URL.createObjectURL(input.files[0]);
    }

    function detectLines(threshold) {
      if (!img) {
        alert('Please load an image first.');
        return;
      }

      const canvas2D = document.getElementById('canvas2D');
      const src = cv.imread(canvas2D);
      const dst = new cv.Mat();

      cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY);
      cv.Canny(src, dst, threshold, threshold * 2, 3, false);

      detectedLines = [];
      const linesP = new cv.Mat();
      cv.HoughLinesP(dst, linesP, 1, Math.PI / 180, 100, 50, 10);

      for (let i = 0; i < linesP.rows; i++) {
        const line = linesP.data32S.subarray(i * 4, i * 4 + 4);
        detectedLines.push({
          x1: line[0],
          y1: line[1],
          x2: line[2],
          y2: line[3]
        });
      }

      src.delete();
      dst.delete();
      linesP.delete();
    }

    function convertTo3D() {
      resetCanvas();
      if (!detectedLines) {
        alert('Please detect lines first.');
        return;
      }

      const groundWidth = 600; // Adjust as needed
      const groundHeight = 600; // Adjust as needed

      const ground = BABYLON.MeshBuilder.CreateGround('ground', { width: groundWidth, height: groundHeight }, scene);
      ground.position.y = -0.1;

      let minX = Number.MAX_VALUE;
      let minY = Number.MAX_VALUE;
      let maxX = Number.MIN_VALUE;
      let maxY = Number.MIN_VALUE;

      detectedLines.forEach(line => {
        minX = Math.min(minX, line.x1, line.x2);
        minY = Math.min(minY, -line.y1, -line.y2);
        maxX = Math.max(maxX, line.x1, line.x2);
        maxY = Math.max(maxY, -line.y1, -line.y2);
      });

      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;

      detectedLines.forEach(line => {
        const points = [
          new BABYLON.Vector3(line.x1 - centerX, 0, -line.y1 + centerY),
          new BABYLON.Vector3(line.x1 - centerX, wallHeight, -line.y1 + centerY),
          new BABYLON.Vector3(line.x2 - centerX, wallHeight, -line.y2 + centerY),
          new BABYLON.Vector3(line.x2 - centerX, 0, -line.y2 + centerY),
          new BABYLON.Vector3(line.x1 - centerX, 0, -line.y1 + centerY)
        ];

        const wallMesh = BABYLON.MeshBuilder.CreateDashedLines(null, { points, dashSize: lineThickness, updatable: true });
        wallMesh.color = new BABYLON.Color3.FromHexString(wallColor);

        if (wallTexture) {
          const wallMaterial = new BABYLON.StandardMaterial("wallMaterial", babylonCanvas._babylonScene);
          wallMaterial.diffuseTexture = new BABYLON.Texture(wallTexture, babylonCanvas._babylonScene);
          wallMesh.material = wallMaterial;
        }

        wallMesh.scaling.y = wallThickness;

        const groundMesh = BABYLON.Mesh.MergeMeshes([ground, wallMesh]);
      });
    }

    window.onload = function () {
      babylonCanvas = document.getElementById('canvas3D');
      const engine = new BABYLON.Engine(babylonCanvas, true);
      scene = new BABYLON.Scene(engine);

      camera = new BABYLON.UniversalCamera('camera', new BABYLON.Vector3(0, 0, -200), scene);
      camera.setTarget(BABYLON.Vector3.Zero());
      camera.attachControl(babylonCanvas, true);

      const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(1, 1, 0));

      scene.clearColor = new BABYLON.Color4(0.9, 0.9, 0.9, 1);

      engine.runRenderLoop(function () {
        scene.render();
      });
    };

    function resetCanvas() {
      if (babylonCanvas) {
        babylonCanvas.style.display = 'none';

        const newCanvas = document.createElement('canvas');
        newCanvas.width = babylonCanvas.width;
        newCanvas.height = babylonCanvas.height;
        babylonCanvas.parentNode.replaceChild(newCanvas, babylonCanvas);

        babylonCanvas = newCanvas;

        const engine = new BABYLON.Engine(babylonCanvas, true);
        scene = new BABYLON.Scene(engine);

        camera = new BABYLON.UniversalCamera('camera', new BABYLON.Vector3(0, 0, -200), scene);
        camera.setTarget(BABYLON.Vector3.Zero());
        camera.attachControl(babylonCanvas, true);

        const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(1, 1, 0));

        scene.clearColor = new BABYLON.Color4(0.9, 0.9, 0.9, 1);

        engine.runRenderLoop(function () {
          scene.render();
        });

        babylonCanvas._babylonEngine = engine;
        babylonCanvas._babylonScene = scene;

        babylonCanvas.style.display = 'block';
      }
    }

    function drawLine() {
      const canvas2D = document.getElementById('canvas2D');
      const context2D = canvas2D.getContext('2d');

      canvas2D.addEventListener('click', function (event) {
        const mouseX = event.clientX - canvas2D.getBoundingClientRect().left;
        const mouseY = event.clientY - canvas2D.getBoundingClientRect().top;

        if (!startPoint) {
          startPoint = { x: mouseX, y: mouseY };
        } else {
          const endPoint = { x: mouseX, y: mouseY };

          context2D.beginPath();
          context2D.strokeStyle = 'red';
          context2D.moveTo(startPoint.x, startPoint.y);
          context2D.lineTo(endPoint.x, endPoint.y);
          context2D.stroke();

          const newLine = {
            x1: startPoint.x,
            y1: startPoint.y,
            x2: endPoint.x,
            y2: endPoint.y,
            timestamp: new Date()
          };
          detectedLines.push(newLine);

          startPoint = null;
        }
      });
    }

    function deleteSelectedLines() {
      if (!detectedLines) {
        alert('Please detect lines first.');
        return;
      }

      const canvas2D = document.getElementById('canvas2D');
      const context2D = canvas2D.getContext('2d');

      canvas2D.addEventListener('click', function (event) {
        const mouseX = event.clientX - canvas2D.getBoundingClientRect().left;
        const mouseY = event.clientY - canvas2D.getBoundingClientRect().top;

        detectedLines.forEach((line, index) => {
          const distToLine = pointToLineDistance({ x: mouseX, y: mouseY }, line);
          if (distToLine < 5) {
            line.timestamp = new Date();
            detectedLines.splice(index, 1);

            context2D.clearRect(0, 0, canvas2D.width, canvas2D.height);
            context2D.drawImage(img, 0, 0, canvas2D.width, canvas2D.height);

            context2D.beginPath();
            context2D.strokeStyle = 'red';
            detectedLines.forEach(line => {
              context2D.moveTo(line.x1, line.y1);
              context2D.lineTo(line.x2, line.y2);
            });
            context2D.stroke();
          }
        });
      });
    }

    function pointToLineDistance(point, line) {
      const { x, y } = point;
      const { x1, y1, x2, y2 } = line;

      const A = x - x1;
      const B = y - y1;
      const C = x2 - x1;
      const D = y2 - y1;

      const dot = A * C + B * D;
      const lenSq = C * C + D * D;
      let param = -1;
      if (lenSq !== 0) {
        param = dot / lenSq;
      }

      let xx, yy;
      if (param < 0) {
        xx = x1;
        yy = y1;
      } else if (param > 1) {
        xx = x2;
        yy = y2;
      } else {
        xx = x1 + param * C;




// Calculate the distance from a point to a line
function pointToLineDistance(point, line) {
  const { x, y } = point;
  const { x1, y1, x2, y2 } = line;

  const A = x - x1;
  const B = y - y1;
  const C = x2 - x1;
  const D = y2 - y1;

  const dot = A * C + B * D;
  const lenSq = C * C + D * D;
  let param = -1;
  if (lenSq !== 0) {
    param = dot / lenSq;
  }

  let xx, yy;
  if (param < 0) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x2;
    yy = y2;
  } else {
    xx = x1 + param * C;
    yy = y1 + param * D;
  }

  const dx = x - xx;
  const dy = y - yy;
  return Math.sqrt(dx * dx + dy * dy);
}


function undo() {
  const canvas2D = document.getElementById('canvas2D');
  const context2D = canvas2D.getContext('2d');

  if (deletedLines.length > 0) {
    // Get the last deleted line from the array
    const lastDeletedLine = deletedLines.pop();

    // Clear the canvas
    context2D.clearRect(0, 0, canvas2D.width, canvas2D.height);
    context2D.drawImage(img, 0, 0, canvas2D.width, canvas2D.height);

    // Check if the last deleted line has a timestamp
    if (lastDeletedLine.timestamp) {
      // Reinstate the line from deletedLines
      detectedLines.push(lastDeletedLine);
    } else {
      // Remove the last line from the detectedLines array
      detectedLines.pop();
    }

    // Redraw remaining lines
    context2D.beginPath();
    context2D.strokeStyle = 'red'; // Change the color as needed
    detectedLines.forEach(line => {
      context2D.moveTo(line.x1, line.y1);
      context2D.lineTo(line.x2, line.y2);
    });
    context2D.stroke();

    // Log or handle the undo action accordingly
    console.log('Undid the last action:', lastDeletedLine);
  }
}


    
  </script>
</body>

</html>
