<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Processing and 3D Rendering</title>
  <!-- Include OpenCV.js -->
  <script async src="https://docs.opencv.org/master/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
  <!-- Include Babylon.js -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <style>
    #canvasContainer {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    #canvas3D {
      width: 100%;
      height: 100%;
      display: block;
    }

    button {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 24px;
      padding: 15px;
    }

    .custom-file-input {
      padding: 15px;
      font-size: 50px;
    }

    .wide-slider {
      width: calc(100% + 40px);
      margin: 10px -20px;
    }

    body {
      font-size: 24px;
    }

    label {
      display: block;
      margin-top: 10px;
    }

    input {
      font-size: 24px;
      margin: 10px;
    }
  </style>
</head>

<body>
  <input type="file" id="imageInput" accept="image/*" onchange="loadAndDetect()" class="custom-file-input">

  <label for="lineThreshold">Line Threshold:</label>
  <input type="range" id="lineThreshold" class="wide-slider" min="1" max="1000" value="270" onchange="updateLineThreshold(this.value)">
  <span id="lineThresholdValue">270</span>

  <label for="lineThickness">Line Thickness:</label>
  <input type="range" id="lineThickness" class="wide-slider" min="1" max="100" value="50" onchange="updateLineThickness(this.value)">
  <span id="lineThicknessValue">50</span>

  <label for="wallColor">Wall Color:</label>
  <input type="color" id="wallColor" value="#000000">

  <label for="wallTexture">Wall Texture:</label>
  <input type="text" id="wallTexture" placeholder="Texture URL" value="https://www.babylonjs-playground.com/textures/brick.jpg">

  <label for="wallHeight">Wall Height:</label>
  <input type="number" id="wallHeight" value="250">

  <label for="wallThickness">Wall Thickness:</label>
  <input type="number" id="wallThickness" value="0.2">

  <div id="canvasContainer">
    <button onclick="toggleFullscreen()">Toggle Fullscreen</button>
    <canvas id="canvas3D" width="1200" height="1200"></canvas>
  </div>

  <p id="coordinates"></p>

  <script>
    let img, context2D, babylonCanvas, detectedLines, scene, camera;

    function onOpenCvReady() {
      // OpenCV is ready
    }

    function updateLineThreshold(value) {
      document.getElementById('lineThresholdValue').textContent = value;
      loadAndDetect();
    }

    function updateLineThickness(value) {
      document.getElementById('lineThicknessValue').textContent = value;
      // You can add real-time adjustment logic for line thickness here if needed
    }

    function loadAndDetect() {
      const input = document.getElementById('imageInput');
      img = new Image();
      img.onload = function () {
        context2D = document.getElementById('canvas2D').getContext('2d');
        context2D.clearRect(0, 0, context2D.canvas.width, context2D.canvas.height);
        context2D.drawImage(img, 0, 0, context2D.canvas.width, context2D.canvas.height);
        const threshold = parseInt(document.getElementById('lineThreshold').value);
        detectLines(threshold);

        // Draw the detected lines on the 2D canvas
        context2D.beginPath();
        context2D.strokeStyle = 'red'; // Change the color as needed
        detectedLines.forEach(line => {
          context2D.moveTo(line.x1, line.y1);
          context2D.lineTo(line.x2, line.y2);
        });
        context2D.stroke();
      };
      img.src = URL.createObjectURL(input.files[0]);
    }

    function detectLines(threshold) {
      if (!img) {
        alert('Please load an image first.');
        return;
      }

      const canvas2D = document.getElementById('canvas2D');
      const src = cv.imread(canvas2D);
      const dst = new cv.Mat();

      cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY);
      cv.Canny(src, dst, threshold, threshold * 2, 3, false);

      detectedLines = [];
      const linesP = new cv.Mat();
      cv.HoughLinesP(dst, linesP, 1, Math.PI / 180, 100, 50, 10);

      for (let i = 0; i < linesP.rows; i++) {
        const line = linesP.data32S.subarray(i * 4, i * 4 + 4);
        detectedLines.push({
          x1: line[0],
          y1: line[1],
          x2: line[2],
          y2: line[3]
        });
      }

      src.delete();
      dst.delete();
      linesP.delete();
    }

    function convertTo3D() {
      resetCanvas();
      if (!detectedLines) {
        alert('Please detect lines first.');
        return;
      }

      let minX = Number.MAX_VALUE;
      let minY = Number.MAX_VALUE;
      let maxX = Number.MIN_VALUE;
      let maxY = Number.MIN_VALUE;

      detectedLines.forEach(line => {
        minX = Math.min(minX, line.x1, line.x2);
        minY = Math.min(minY, -line.y1, -line.y2);
        maxX = Math.max(maxX, line.x1, line.x2);
        maxY = Math.max(maxY, -line.y1, -line.y2);
      });

      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;

      detectedLines.forEach(line => {
        const lineThickness = parseFloat(document.getElementById('lineThickness').value);
        const wallColor = document.getElementById('wallColor').value;
        const wallTexture = document.getElementById('wallTexture').value;
        const wallHeight = parseFloat(document.getElementById('wallHeight').value);
        const wallThickness = parseFloat(document.getElementById('wallThickness').value);

        const points = [
          new BABYLON.Vector3(line.x1 - centerX, 0, -line.y1 + centerY),
          new BABYLON.Vector3(line.x1 - centerX, wallHeight, -line.y1 + centerY),
          new BABYLON.Vector3(line.x2 - centerX, wallHeight, -line.y2 + centerY),
          new BABYLON.Vector3(line.x2 - centerX, 0, -line.y2 + centerY),
          new BABYLON.Vector3(line.x1 - centerX, 0, -line.y1 + centerY)
        ];

        const wallMesh = BABYLON.MeshBuilder.CreateDashedLines(null, { points, dashSize: lineThickness, updatable: true });
        wallMesh.color = new BABYLON.Color3.FromHexString(wallColor);

        if (wallTexture) {
          const wallMaterial = new BABYLON.StandardMaterial("wallMaterial", babylonCanvas._babylonScene);
          wallMaterial.diffuseTexture = new BABYLON.Texture(wallTexture, babylonCanvas._babylonScene);
          wallMesh.material = wallMaterial;
        }

        wallMesh.scaling.y = wallThickness;
      });
    }

    window.onload = function () {
      babylonCanvas = document.getElementById('canvas3D');
      const engine = new BABYLON.Engine(babylonCanvas, true);
      scene = new BABYLON.Scene(engine);

      camera = new BABYLON.UniversalCamera('camera', new BABYLON.Vector3(0, 0, -200), scene);
      camera.setTarget(BABYLON.Vector3.Zero());
      camera.attachControl(babylonCanvas, true);

      const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(1, 1, 0));
      scene.clearColor = new BABYLON.Color4(0.9, 0.9, 0.9, 1);

      engine.runRenderLoop(function () {
        scene.render();
      });
    };

    function resetCanvas() {
      if (babylonCanvas) {
        babylonCanvas.style.display = 'none';

        const newCanvas = document.createElement('canvas');
        newCanvas.width = babylonCanvas.width;
        newCanvas.height = babylonCanvas.height;
        babylonCanvas.parentNode.replaceChild(newCanvas, babylonCanvas);

        babylonCanvas = newCanvas;

        const engine = new BABYLON.Engine(babylonCanvas, true);
        const newScene = new BABYLON.Scene(engine);

        const camera = new BABYLON.UniversalCamera('camera', new BABYLON.Vector3(0, 0, -200), newScene);
        camera.setTarget(BABYLON.Vector3.Zero());
        camera.attachControl(babylonCanvas, true);

        const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(1, 1, 0));
        newScene.clearColor = new BABYLON.Color4(0.9, 0.9, 0.9, 1);

        const animationDuration = 10;
        const zoomedOutPosition = new BABYLON.Vector3(0, 100, -1800);

        const animation = new BABYLON.Animation(
          'cameraZoom',
          'position',
          60,
          BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
          BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
        );

        const keys = [
          { frame: 0, value: camera.position.clone() },
          { frame: animationDuration, value: zoomedOutPosition }
        ];

        animation.setKeys(keys);
        camera.animations.push(animation);

        newScene.beginAnimation(camera, 0, animationDuration, false);

        engine.runRenderLoop(function () {
          newScene.render();
        });

        babylonCanvas._babylonEngine = engine;
        babylonCanvas._babylonScene = newScene;

        babylonCanvas.style.display = 'block';
      }
    }

    function toggleFullscreen() {
      const canvasContainer = document.getElementById("canvasContainer");
      if (!document.fullscreenElement) {
        canvasContainer.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    }
  </script>
</body>

</html>
