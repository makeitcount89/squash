<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
  <script async src="https://docs.opencv.org/master/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <style>
    canvas {
      display: block;
      margin: 0 auto;
    }
  </style>
  <title>Image to 3D</title>
</head>
<body>

<input type="file" id="imageInput" />
<button onclick="loadImage()">Load Image</button>
<button onclick="findBoundingBox()">Find Bounding Box</button>
<button onclick="render3D()">Render 3D</button>

<div id="imageContainer"></div>
<div id="renderCanvas"></div>

<script>
  let img;
  let boundingBox;

  function onOpenCvReady() {
    // OpenCV is ready
    console.log('OpenCV.js is ready.');
    document.getElementById('loadingMessage').textContent = 'OpenCV.js is ready.';
  }

  function loadImage() {
    const input = document.getElementById('imageInput');
    const container = document.getElementById('imageContainer');

    const file = input.files[0];
    const reader = new FileReader();

    reader.onload = function (e) {
      img = new Image();
      img.src = e.target.result;

      img.onload = function () {
        container.innerHTML = `<img src="${img.src}" alt="Selected Image" width="300" height="300"/>`;
      };
    };

    reader.readAsDataURL(file);
  }

  function findBoundingBox() {
    if (!img) {
      alert('Please load an image first.');
      return;
    }

    cv.imread(img, (mat) => {
      cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY);
      cv.threshold(mat, mat, 128, 255, cv.THRESH_BINARY);

      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();
      cv.findContours(mat, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      const largestContour = getLargestContour(contours);
      boundingBox = cv.boundingRect(largestContour);

      console.log('Bounding Box Coordinates:', boundingBox);
      alert(`Bounding Box Coordinates:\nX: ${boundingBox.x}, Y: ${boundingBox.y}, Width: ${boundingBox.width}, Height: ${boundingBox.height}`);

      contours.delete();
      hierarchy.delete();
      mat.delete();
    });
  }

  function getLargestContour(contours) {
    let maxArea = -1;
    let maxContour = null;

    for (let i = 0; i < contours.size(); i++) {
      const area = cv.contourArea(contours.get(i));
      if (area > maxArea) {
        maxArea = area;
        maxContour = contours.get(i);
      }
    }

    return maxContour;
  }

  function render3D() {
    if (!boundingBox) {
      alert('Please find bounding box coordinates first.');
      return;
    }

    // Create Babylon.js scene and camera
    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);
    const camera = new BABYLON.ArcRotateCamera("Camera", 0, 0, 10, BABYLON.Vector3.Zero(), scene);
    camera.attachControl(canvas, true);

    // Create a box using bounding box coordinates
    const box = BABYLON.MeshBuilder.CreateBox("box", {
      width: boundingBox.width,
      height: boundingBox.height,
      depth: 1
    }, scene);

    // Move the box to the position based on bounding box coordinates
    box.position.x = boundingBox.x + boundingBox.width / 2;
    box.position.y = -boundingBox.y - boundingBox.height / 2; // Invert y-axis to match Babylon.js coordinate system

    // Run the Babylon.js engine
    engine.runRenderLoop(function () {
      scene.render();
    });
  }
</script>

</body>
</html>
