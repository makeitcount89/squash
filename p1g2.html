<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Processing and 3D Rendering</title>
  <!-- Include OpenCV.js -->
  <script async src="https://docs.opencv.org/master/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
  <!-- Include Babylon.js -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <style>
    .custom-file-input {
  padding: 15px; /* Adjust padding as needed */
  font-size: 50px; /* Adjust font size as needed */
  /* Add any additional styling you want */
    }
    
    .wide-slider {
  width: calc(100% + 40px); /* Adjust the width as needed */
  margin: 10px -20px; /* Compensate for the increased width */
    }
    
    #canvas2D,
    #canvas3D {
      border: 1px solid #000;
      margin-top: 20px;
    }

    body {
      font-size: 24px;
    }

    label {
      display: block;
      margin-top: 10px;
    }

    button {
      font-size: 24px;
      padding: 15px;
      margin: 10px;
    }

    input {
      font-size: 24px;
      margin: 10px;
    }
  </style>
</head>

<body>
  <input type="file" id="imageInput" accept="image/*" onchange="loadAndDetect()" class="custom-file-input">
  
  <label for="lineThreshold">Line Threshold:</label>
<input type="range" id="lineThreshold" class="wide-slider" min="1" max="1000" value="270" onchange="updateLineThreshold(this.value)">
<span id="lineThresholdValue">270</span>

<label for="lineThickness">Line Thickness:</label>
<input type="range" id="lineThickness" class="wide-slider" min="1" max="100" value="50" onchange="updateLineThickness(this.value)">
<span id="lineThicknessValue">50</span>
  
  <label for="wallColor">Wall Color:</label>
  <input type="color" id="wallColor" value="#000000">

  <label for="wallTexture">Wall Texture:</label>
  <input type="text" id="wallTexture" placeholder="Texture URL" value="https://www.babylonjs-playground.com/textures/brick.jpg">

  <label for="wallHeight">Wall Height:</label>
  <input type="number" id="wallHeight" value="250">

  <label for="wallThickness">Wall Thickness:</label>
  <input type="number" id="wallThickness" value="0.2">

  <button onclick="convertTo3D()">Convert to 3D</button>
  <!-- Add this button within your <body> tag -->
<button onclick="toggleFullScreen()">Toggle Fullscreen</button>
  
  <canvas id="canvas2D" width="600" height="600"></canvas>
  <canvas id="canvas3D" width="1200" height="1200"></canvas>

  <p id="coordinates"></p>

  <script>

    let img, context2D, babylonCanvas, detectedLines, scene, camera; // Move 'scene' to a higher scope

    function onOpenCvReady() {
      // OpenCV is ready
    }

    function updateLineThreshold(value) {
      document.getElementById('lineThresholdValue').textContent = value;
      loadAndDetect(); // Trigger line detection on threshold change
    }

    function updateLineThickness(value) {
      document.getElementById('lineThicknessValue').textContent = value;
      // You can add real-time adjustment logic for line thickness here if needed
    }

    function loadAndDetect() {
  const input = document.getElementById('imageInput');
  img = new Image();
  img.onload = function () {
    context2D = document.getElementById('canvas2D').getContext('2d');
    context2D.clearRect(0, 0, context2D.canvas.width, context2D.canvas.height);
    context2D.drawImage(img, 0, 0, context2D.canvas.width, context2D.canvas.height);
    const threshold = parseInt(document.getElementById('lineThreshold').value);
    detectLines(threshold);

    // Draw the detected lines on the 2D canvas
    context2D.beginPath();
    context2D.strokeStyle = 'red'; // Change the color as needed
    detectedLines.forEach(line => {
      context2D.moveTo(line.x1, line.y1);
      context2D.lineTo(line.x2, line.y2);
    });
    context2D.stroke();
  };
  img.src = URL.createObjectURL(input.files[0]);
    }
    
    function detectLines(threshold) {
      if (!img) {
        alert('Please load an image first.');
        return;
      }

      const canvas2D = document.getElementById('canvas2D');
      const src = cv.imread(canvas2D);
      const dst = new cv.Mat();

      cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY);
      cv.Canny(src, dst, threshold, threshold * 2, 3, false); // Adjust the threshold here

      // Convert the detected lines to Babylon.js format
      detectedLines = [];
      const linesP = new cv.Mat();
      cv.HoughLinesP(dst, linesP, 1, Math.PI / 180, 100, 50, 10);

      for (let i = 0; i < linesP.rows; i++) {
        const line = linesP.data32S.subarray(i * 4, i * 4 + 4);
        detectedLines.push({
          x1: line[0],
          y1: line[1],
          x2: line[2],
          y2: line[3]
        });
      }

      src.delete();
      dst.delete();
      linesP.delete();
    }

    function convertTo3D() {
      resetCanvas();
      if (!detectedLines) {
        alert('Please detect lines first.');
        return;
      }

      // Determine the bounding box of the 3D object
      let minX = Number.MAX_VALUE;
      let minY = Number.MAX_VALUE;
      let maxX = Number.MIN_VALUE;
      let maxY = Number.MIN_VALUE;

      detectedLines.forEach(line => {
        minX = Math.min(minX, line.x1, line.x2);
        minY = Math.min(minY, -line.y1, -line.y2);
        maxX = Math.max(maxX, line.x1, line.x2);
        maxY = Math.max(maxY, -line.y1, -line.y2);
      });

      // Calculate the center and dimensions of the bounding box
      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;
      const width = maxX - minX;
      const height = maxY - minY;

      detectedLines.forEach(line => {
        const lineThickness = parseFloat(document.getElementById('lineThickness').value);
        const wallColor = document.getElementById('wallColor').value;
        const wallTexture = document.getElementById('wallTexture').value;
        const wallHeight = parseFloat(document.getElementById('wallHeight').value);
        const wallThickness = parseFloat(document.getElementById('wallThickness').value);

        // Center and normalize the object
        const points = [
          new BABYLON.Vector3(line.x1 - centerX, 0, -line.y1 + centerY),
          new BABYLON.Vector3(line.x1 - centerX, wallHeight, -line.y1 + centerY),
          new BABYLON.Vector3(line.x2 - centerX, wallHeight, -line.y2 + centerY),
          new BABYLON.Vector3(line.x2 - centerX, 0, -line.y2 + centerY),
          new BABYLON.Vector3(line.x1 - centerX, 0, -line.y1 + centerY)
        ];

        const wallMesh = BABYLON.MeshBuilder.CreateDashedLines(null, { points, dashSize: lineThickness, updatable: true });
        wallMesh.color = new BABYLON.Color3.FromHexString(wallColor);

        if (wallTexture) {
          const wallMaterial = new BABYLON.StandardMaterial("wallMaterial", babylonCanvas._babylonScene);
          wallMaterial.diffuseTexture = new BABYLON.Texture(wallTexture, babylonCanvas._babylonScene);
          wallMesh.material = wallMaterial;
        }

        wallMesh.scaling.y = wallThickness;
      });
        
    }
    

    // Load Babylon canvas on page load
  window.onload = function () {
  babylonCanvas = document.getElementById('canvas3D');
  const engine = new BABYLON.Engine(babylonCanvas, true);
  const scene = new BABYLON.Scene(engine);

  // Set up camera and light
  const camera = new BABYLON.UniversalCamera('camera', new BABYLON.Vector3(0, 0, -200), scene);
camera.setTarget(BABYLON.Vector3.Zero());
camera.attachControl(babylonCanvas, true);

// Animation parameters
const animationDuration = 700; // in milliseconds
const zoomedOutPosition = new BABYLON.Vector3(0, 100, -1800);
    camera.rotation.x = Math.PI / 12; 

// Create a position animation
const animation = new BABYLON.Animation(
  'cameraZoom',
  'position',
  60,
  BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
  BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
);

// Set keyframes for the animation
const keys = [
  { frame: 0, value: camera.position.clone() },
  { frame: animationDuration, value: zoomedOutPosition }
];

// Add keys to the animation
animation.setKeys(keys);

// Attach the animation to the camera
camera.animations.push(animation);

// Run the animation
scene.beginAnimation(camera, 0, animationDuration, false);
    

  // Rotate the camera to face the object
  //camera.rotation.y = Math.PI; // Rotate by 180 degrees + 20 degrees
  //camera.rotation.x = Math.PI / 5; // Adjust the angle to tilt the camera down
    
  

  const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(1, 1, 0));

  // Set background color to a lighter gray
  scene.clearColor = new BABYLON.Color4(0.9, 0.9, 0.9, 1);

  // Run the Babylon.js engine
  engine.runRenderLoop(function () {
    scene.render();
  });
};


    function resetCanvas() {
  if (babylonCanvas) {
    // Hide the Babylon canvas
    babylonCanvas.style.display = 'none';

    // Create a new Babylon canvas element
    const newCanvas = document.createElement('canvas');
    newCanvas.id = 'canvas3D'; 
    newCanvas.width = babylonCanvas.width;
    newCanvas.height = babylonCanvas.height;
    babylonCanvas.parentNode.replaceChild(newCanvas, babylonCanvas);

    babylonCanvas = newCanvas;

    // Create a new Babylon engine and scene
    const engine = new BABYLON.Engine(babylonCanvas, true);
    const newScene = new BABYLON.Scene(engine);

    // Set up camera and light for the new scene (you may need to adjust these parameters)
    const camera = new BABYLON.UniversalCamera('camera', new BABYLON.Vector3(0, 0, -200), newScene);
    camera.setTarget(BABYLON.Vector3.Zero());
    camera.attachControl(babylonCanvas, true);
    const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(1, 1, 0));

    // Set background color to a lighter gray
    newScene.clearColor = new BABYLON.Color4(0.9, 0.9, 0.9, 1);

    // Animation parameters
    const animationDuration = 10; // in milliseconds
    const zoomedOutPosition = new BABYLON.Vector3(0, 100, -1800);

    // Create a position animation
    const animation = new BABYLON.Animation(
      'cameraZoom',
      'position',
      60,
      BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
      BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
    );

    // Set keyframes for the animation
    const keys = [
      { frame: 0, value: camera.position.clone() },
      { frame: animationDuration, value: zoomedOutPosition }
    ];

    // Add keys to the animation
    animation.setKeys(keys);

    // Attach the animation to the camera
    camera.animations.push(animation);

    // Run the animation
    newScene.beginAnimation(camera, 0, animationDuration, false);

    // Run the Babylon.js engine for the new scene
    engine.runRenderLoop(function () {
      newScene.render();
    });

    // Update the babylonCanvas and babylonScene variables
    babylonCanvas._babylonEngine = engine;
    babylonCanvas._babylonScene = newScene;

    // Show the new Babylon canvas
    babylonCanvas.style.display = 'block';
  }
    }
    function toggleFullScreen() {
  const babylonCanvas = document.getElementById('canvas3D');

  if (!document.fullscreenElement) {
    babylonCanvas.requestFullscreen().catch(err => {
      alert(`Error attempting to enable full-screen mode: ${err.message}`);
    });
  } else {
    document.exitFullscreen();
  }
    }
    
  </script>
</body>

</html>
